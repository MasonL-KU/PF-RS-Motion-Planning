clear
clc
close all

%% Particle Filter Reweighting Smoothing Motion Planning
% PF-RS Motion Planning
% Mason Lieb ISSL
% 2022

% This is the main code for the simulations associated with the project
% report included on GitHub.

%% Simulation Parameters
dt = 0.05;          % Discretization time [s/step]
Th = 1;             % Planning Horizon [s]
Tp = round(Th/dt);  % Prediction steps in filtering/smoothing

%% Setup PF Functions and Covariances
nx = 7;
ny = 2;

% Process Noise
% Covariance matrix Q is generated by 'getModeCovariance.m' function
mu = zeros(nx,1);                       % Virtual system noise mean vector
gen_sys_noise = @(mu,Q) mvnrnd(mu,Q);   % Generate system noise
gen_x0 = @(x,N,Q) mvnrnd(x,Q,N);        % Samples initial particle set

% Measurement Noise
% Measurement noise covariance R generated by 'getModeCovariance.m'
% function
nv = 5;     % Number of measurement terms = 3 + Nobs
p_obs_noise = @(x,y,R) mvnpdf(x,y,R);

% Likelihood function
p_y_given_x = @(y,x,Z) p_obs_noise(measure(x,Z),y,Z.R);

%% Particle Filter Structure
pf.Tp = Tp;                             % Planning horizon
pf.k = 2;                               % Initial time step
pf.N = 250;                             % Particle count N
pf.wf = repmat(1/pf.N, pf.N, Tp);       % Initialize uniform filter weights
pf.ws = pf.wf;                          % Initialize smoothing weights
pf.particles = zeros(nx,pf.N,Tp);       % Initialize particle memory
pf.p_y_given_x = p_y_given_x;           % Assign likelihood function
pf.gen_sys_noise = gen_sys_noise;       % Assign system noise generator function
pf.gen_x0 = gen_x0;                     % Assign initial sampling function         
pf.dt = dt;                             % Discretization time

%% Define Driving Scenario
% Scenario includes ego and obstacle vehicle positions and velocities
% Scenario determines obstacle behavior
%  Edit scenario file to move obstacle waypoints and adjust velocities
[scenario,EV] = Straight_2Lane_Road();
EV.Velocity = [20, 0, 0];       % Write initial velocity to ego vehicle
scenario.SampleTime = dt;       % Assign sampling time to scenario

% Read lane boundaries
% This is not required for the algorithm to run, but is used to add the
% measured lane boundaries to the BirdsEyePlot
lb = laneBoundaries(EV,'XDistance',1:1:Th*norm(EV.Velocity),'LocationType','Center');

% Scenario Plot
plot(scenario);
% Chase Plot of ego vehicle
chasePlot(EV)

% Gets left and right lane boundaries in vehicle's coordinate frame
% These measurements are not required for algorithm to run, but could be
% useful in a future version with curved or diagonal roads
lbl = lb(1).Coordinates;
lbr = lb(2).Coordinates;

% Assign initial sampling mean vector
pf.x0 = [EV.Position(1);    % Global X
         EV.Position(2);    % Global Y
         deg2rad(EV.Yaw);   % Yaw Angle (rad)
         norm(EV.Velocity); % Longitudinal Velocity
         0;                 % Steering angle (rad)
         0;                 % Longidudinal Acceleration
         0];                % Steering rate (rad/s)

% xtrue is the true system's state vector
xtrue = pf.x0;              % Initialize with initial conditions above

numObs = size(scenario.Actors,2)-1;     % Get number of obstacle vehicles
% Add obstacle information to road information structure Z
Z.obs(1,:) = scenario.Actors(2).Position;
Z.obs(2,:) = scenario.Actors(3).Position;
% Generate elliptical obstacle regions
Z.obstacleRegion = getObstacleEllipse(xtrue,Z.obs);

% Define reference
vnom = 30;              % Nominal velocity
r = [vnom 0 0 0 0 0];   % Reference vector
Z.vnom = vnom;          % Assign nominal velocity to road information Z

% Set max number of driving modes to sample in each planning phase
maxModes = 5;
% Initialize memory for saving states and inputs for each planning horizon
% and mode selection
states = zeros(5,Tp,maxModes);
inputs = zeros(2,Tp,maxModes);

%% Set up plots
% These plotting commands taken from MATLAB example: 'Highway Trajectory Planning Using Frenet Reference Path'
bep = birdsEyePlot('XLim',[-40 40],'YLim',[-30 30]);
olPlotter = outlinePlotter(bep);
lblPlotter = laneBoundaryPlotter(bep,'Color','r','LineStyle','-');  % Left lane boundary
lbrPlotter = laneBoundaryPlotter(bep,'Color','g','LineStyle','-');  % Right lane boundary
rbsEdgePlotter = laneBoundaryPlotter(bep);                          % Plot bird's eye plot
legend('off');

% Animated simulation results are saved in gifs
% Get 1st frame of each gif
gifidx = 1;
frame1 = getframe(figure(1));
frame2 = getframe(figure(2));
frame3 = getframe(figure(3));
im1{gifidx} = frame2im(frame1);
im2{gifidx} = frame2im(frame2);
im3{gifidx} = frame2im(frame3);

%% Simulation Loop
iter = 0;       % Keep track of number of iterations - used for storing results
simTime = 0;    % Keep track of overall simulation time

% Simulation will run until either of the obstacle vehicles reaches its
% final waypoint as defined in 'Straight_2Lane_Road.m'
while advance(scenario)
    tic
    iter = iter + 1;
    
    % Plot obstacle region
    Z.obs(1,:) = scenario.Actors(2).Position;
    Z.obs(2,:) = scenario.Actors(3).Position;
    Z.obstacleRegion = getObstacleEllipse(xtrue,Z.obs);
    
    % Road information measurement
    % Source is MATLAB example: 'Highway Trajectory Planning Using Frenet Reference
    % Path'
    rbs = roadBoundaries(EV);
    [position,yaw,length,width,originOffset,color] = targetOutlines(EV);
    lb = laneBoundaries(EV,'XDistance',0:5:50,'LocationType','Center', ...
        'AllBoundaries',false);
    plotLaneBoundary(rbsEdgePlotter,rbs)
    plotLaneBoundary(lblPlotter,{lb(1).Coordinates})
    plotLaneBoundary(lbrPlotter,{lb(2).Coordinates})
    plotOutline(olPlotter,position,yaw,length,width, ...
        'OriginOffset',originOffset,'Color',color)    
    
    % Get Current Lane for paring down feasible modes
    currLane = getCurrentLane(EV);
    
    % Identify obstacle lanes
    LLobs = find(Z.obs(:,2) > 0);
    RLobs = find(Z.obs(:,2) <=0);

    % Array of edge-to-edge obstacle distances
    obsDistances = getEllipseDistance(xtrue,Z);

    % Assign distances obstacles within the current lane
    % Currently only consider one obstacle in each lane
    switch(currLane)
        case(-1.8375)
            % EV is in right lane, use distance to right lane obs
            Z.sameLaneObsDist = obsDistances(RLobs);
            Z.currLaneLabel = "right";
        case(1.8375)
            % EV is in left lane, use distance to left lane obs
            Z.sameLaneObsDist = obsDistances(LLobs);
            Z.currLaneLabel = "left";
    end
    
    % number of mode samples set instead of computation time limit
    numModes = 0;
    modeArray = strings(maxModes,1);    % Initialize mode memory
    cost = zeros(maxModes,1);           % Initialize trajectory cost memory

    % Gif Generation
    gifidx = gifidx + 1;
    frame1 = getframe(figure(1));
    im1{gifidx} = frame2im(frame1);
    frame2 = getframe(figure(2));
    im2{gifidx} = frame2im(frame2);
    frame3 = getframe(figure(3));
    im3{gifidx} = frame2im(frame3);

    while numModes < maxModes
        % Increment number of modes sampled
        numModes = numModes + 1;

        % Obstacle position measurement
        Z.obs(1,:) = scenario.Actors(2).Position;
        Z.obs(2,:) = scenario.Actors(3).Position;
        
        % Initialize Filtering and Smoothing augmented state matrices
        xh = zeros(nx,Tp);
        xh(:,1) = [EV.Position(1);
                   EV.Position(2);
                   deg2rad(EV.Yaw);
                   norm(EV.Velocity);
                   xtrue(5);
                   0;
                   0];
        xs = zeros(nx,Tp);

        % Adjust position to be center of vehicle
        % EV.Position is the center of the rear axle
        xh(1,1) = xh(1,1) + EV.Wheelbase/2*sind(EV.Yaw);
        xh(2,1) = xh(2,1) + EV.Wheelbase/2*cosd(EV.Yaw);
        
        % Get Lane Boundary Information
        lbl = lb(1).Coordinates;
        lbr = lb(2).Coordinates;
       
        % Sample driving mode
        [Z.mode, lkprob] = sampleDrivingMode(xtrue,Z);
        modeArray(numModes) = Z.mode;
        % Assign covariance matrices
        Z = getModeCovariance(Z);

        % Identify current lane centerline coordinate
        currLane = getCurrentLane(EV);
        Z.currLane = currLane;

        % Identify lane changing coordinates
        switch(currLane)
            case(1.8375)
                lkLane = currLane;
                cllLane = currLane + 3.675;
                clrLane = currLane - 3.675;
            case(-1.8375)
                lkLane = currLane;
                cllLane = currLane + 3.675;
                clrLane = currLane - 3.675;
        end

        % Set reference according to selected driving mode
        switch(Z.mode)
            case("LK")
                Z.laneRef = lkLane;
                Z.vnom = vnom;
            case("CLL")
                Z.laneRef = cllLane;
                Z.vnom = vnom;
            case("CLR")
                Z.laneRef = clrLane;
                Z.vnom = vnom;
        end
        
        % FORWARD FILTERING
        for k = 2:Tp
            % Increment time step within planning horizon
            pf.k = k;
            
            % Predict obstacle position
            Z.obs(1,:) = Z.obs(1,:) + scenario.Actors(2).Velocity*dt;
            Z.obs(2,:) = Z.obs(2,:) + scenario.Actors(3).Velocity*dt;
            
            % Generate predicted obstacle region over planning horizon
            Z.obstacleRegion = getObstacleEllipse(xtrue,Z.obs);
            
            % Generate filtering trajectory
            [xh(:,k),pf] = particlefilter(r,pf,Z);
        end

        % REWEIGHTING SMOOTHING
        xs(:,end) = xh(:,end);
        for k = Tp-1:-1:1
            pf.k = k;
            [xs(:,k),pf] = reweightingsmoother(pf,Z);
        end

        % Save the generated trajectory
        states(:,:,numModes) = xs(1:5,:);
        inputs(:,:,numModes) = xs(6:7,:);

        % Evaluate cumulative cost of each generated trajectory
        [cost(numModes),costArray] = trajectoryCost(xs,Z);
    end
    
    fprintf('LK Sample Prob: %f\n',lkprob)
    disparray = [modeArray cost];
    tab = array2table(disparray,'VariableNames',{'Mode','Cost'});
    disp(tab);
    [minCost,costidx] = min(cost);
    switch costidx
        case(1)
            fprintf('mode: %s\n',modeArray(1))
        case(2)
            fprintf('mode: %s\n',modeArray(2))
        case(3)
            fprintf('mode: %s\n',modeArray(3))
        case(4)
            fprintf('mode: %s\n',modeArray(4))
        case(5)
            fprintf('mode: %s\n',modeArray(5))
    end
    
    applyInputs = inputs(:,:,costidx);
    applyStates = states(:,:,costidx);
    
    % Output of reweighting smoother is smoothed trajectory over horizon
    % Apply to ground truth by updating EV state

    % Apply to xtrue
    xtrue = vehicle_model_det(xtrue,applyInputs(:,1),dt);
    pf.x0 = xtrue;
    
    % Update Simulation EV Actor
    EV.Position(1:2) = xtrue(1:2);
    EV.Velocity(1:2) = xtrue(4)*[cos(xtrue(3)) sin(xtrue(3))];
    yawPrev = EV.Yaw;
    EV.Yaw = rad2deg(xtrue(3));
    EV.AngularVelocity(3) = diff([yawPrev EV.Yaw]);
    
    toc
    
    % Store data for static results plotting
    simulationMemoryStates(:,iter) = xtrue;
    InputMemory(:,iter) = applyInputs(:,1);
    laneRef = getLaneRef(modeArray(costidx),currLane);
    modeMemory(iter) = laneRef;

    % Increment total simulation time
    simTime = simTime + toc;
end

% Print total simulation time
fprintf('Total Simulation Time: %f seconds\n',simTime)

%% Save figures 1, 2, and 3 gifs
filename1 = 'ScenarioPlot.gif';
filename2 = 'ChasePlot.gif';
filename3 = 'BirdsEyePlot.gif';
for idx = 1:gifidx
    [A,map1] = rgb2ind(im1{idx},256);
    [B,map2] = rgb2ind(im2{idx},256);
    [C,map3] = rgb2ind(im3{idx},256);
    if idx == 1
        imwrite(A,map1,filename1,'gif','LoopCount',Inf,'DelayTime',0.05);
        imwrite(B,map2,filename2,'gif','LoopCount',Inf,'DelayTime',0.05);
        imwrite(C,map3,filename3,'gif','LoopCount',Inf,'DelayTime',0.05);
    else
        imwrite(A,map1,filename1,'gif','WriteMode','append','DelayTime',0.05);
        imwrite(B,map2,filename2,'gif','WriteMode','append','DelayTime',0.05);
        imwrite(C,map3,filename3,'gif','WriteMode','append','DelayTime',0.05);
    end
end

%% Rerun scenario with generated Ego Vehicle States/Inputs
close all
[scenario,EV] = Straight_2Lane_Road();
scenario.SampleTime = 0.05;
EV.Velocity = [20, 0, 0];
lb = laneBoundaries(EV,'XDistance',1:1:Th*norm(EV.Velocity),'LocationType','Center');
plot(scenario)
chasePlot(EV)

% Set up plots
bep = birdsEyePlot('XLim',[-40 40],'YLim',[-30 30]);
olPlotter = outlinePlotter(bep);
lblPlotter = laneBoundaryPlotter(bep,'Color','r','LineStyle','-');  % Left lane boundary
lbrPlotter = laneBoundaryPlotter(bep,'Color','g','LineStyle','-');  % Right lane boundary
rbsEdgePlotter = laneBoundaryPlotter(bep);                          % Plot bird's eye plot
legend('off');
simStep = 1;
while advance(scenario)
    dt = toc;
    if scenario.SampleTime-dt >0
        pause(scenario.SampleTime-dt);
    end
    rbs = roadBoundaries(EV);
    [position,yaw,length,width,originOffset,color] = targetOutlines(EV);
    lb = laneBoundaries(EV,'XDistance',0:5:50,'LocationType','Center', ...
        'AllBoundaries',false);
    plotLaneBoundary(rbsEdgePlotter,rbs)
    plotLaneBoundary(lblPlotter,{lb(1).Coordinates})
    plotLaneBoundary(lbrPlotter,{lb(2).Coordinates})
    plotOutline(olPlotter,position,yaw,length,width, ...
        'OriginOffset',originOffset,'Color',color)    
    xtrue = simulationMemoryStates(:,simStep);
    EV.Position(1:2) = xtrue(1:2);
    EV.Velocity(1:2) = xtrue(4)*[cos(xtrue(3)) sin(xtrue(3))];
    yawPrev = EV.Yaw;
    EV.Yaw = rad2deg(xtrue(3));
    EV.AngularVelocity(3) = diff([yawPrev EV.Yaw]);
    simStep = simStep + 1;
    tic;
end

%% Generate simulation static plots
% Lane tracking
time = 0.05:0.05:iter*0.05;
xTraj = simulationMemoryStates(1,:);
yTraj = simulationMemoryStates(2,:);
steeringrate = rad2deg(InputMemory(2,:));
steeringangle = rad2deg(simulationMemoryStates(5,:));
leftLimit = repmat(3.675,1,iter);
rightLimit = repmat(-3.675,1,iter);

% Mode (lane) Tracking Position Axis
figure(4)
plot(xTraj,yTraj,'k','LineWidth',2)
ylim([-4 4])
xlim([0 315])
hold on
stairs(xTraj,modeMemory,':k')
plot(xTraj,leftLimit,'--k','LineWidth',2)
plot(xTraj,rightLimit,'--k','LineWidth',2)
xlabel('Longitudinal Position [m]')
ylabel('Lateral Position [m]')
legend({'Vehicle Position','Driving Mode Reference Lane','Road Boundaries'})

% Mode (lane) Tracking Time Axis
figure(5)
plot(time,yTraj,'k','LineWidth',2)
hold on
ylim([-4,4])
xlim([0 12])
stairs(time,modeMemory,':k')
plot(time,leftLimit,'--k','LineWidth',2)
plot(time,rightLimit,'--k','LineWidth',2)
xlabel('Time [s]')
ylabel('Lateral Position [m]')
legend({'Vehicle Position','Driving Mode Reference Lane','Road Boundaries'})

% Velocity tracking
velocities = simulationMemoryStates(4,:);
nominal = repmat(vnom,size(velocities));

% Time axis velocity plots
figure(6)
subplot(2,1,1)
stairs(time,InputMemory(1,:),'k')
xlabel('Time [s]')
ylabel('Acceleration [m/s^2]')
xlim([0 12])

subplot(2,1,2)
plot(time,velocities,'k')
hold on
xlabel('Time [s]')
ylabel('Velocity [m/s]')
ylim([20 35])
xlim([0 12])
plot(time,nominal,'--k')

% Position axis steering plots
figure(7)
subplot(2,1,1)
stairs(time,steeringrate,'k')
xlabel('Time [s]')
ylabel('Steering Rate [deg/s]')
xlim([0 12])

subplot(2,1,2)
plot(time,steeringangle,'k')
xlabel('Time [s]')
ylabel('Steering Angle [deg]')
xlim([0 12])

